{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello Dict+ Dict+ is a useful solution to all your dictionary needs! You have access to .Changed on shallow and deep tables. Functions to find and add just like table. This is a powerful module that allows you to save massive lines of code. It is very lightweight and will not tax on your game. With this non-intrusive module that adds nothing more to your game this will re-define the way your work. Installation You must download the .rbxm file on the github realeses page. Then insert it into a Service like ReplicatedStorage or Server Storage.","title":"Hello Dict+"},{"location":"#hello-dict","text":"Dict+ is a useful solution to all your dictionary needs! You have access to .Changed on shallow and deep tables. Functions to find and add just like table. This is a powerful module that allows you to save massive lines of code. It is very lightweight and will not tax on your game. With this non-intrusive module that adds nothing more to your game this will re-define the way your work.","title":"Hello Dict+"},{"location":"#installation","text":"You must download the .rbxm file on the github realeses page. Then insert it into a Service like ReplicatedStorage or Server Storage.","title":"Installation"},{"location":"about/","text":"Functions As you are aware this module comes with lots of functions that can be used from any script as you can require it. This is the basic table we will be using: local d = require(game.ReplicatedStorage.DictModule) -- This can be you requiring the module local a = { -- This is a test table that we will use ['Lol'] = { ['Hi'] = 1, ['Bruh'] = 2, } } module.find In order to find a spefic Key in this table you should do: print(d.find(a.Lol, 'Hi')) -- 1 d.find can be used on a regular table to do this print(d.find(a), 'Lol') The first argument must be the dict you are looking in and the second argument being the string Key Name module.remove You can also Remove Key's in a dict. The way to do this is to use d.remove print(d.remove(a.Lol, 'Hi')) The first arg must be the dict and the second arg must be the string name of what you are removing. Hence any refrences to a.Lol.Hi will be nil as it's gone from the table. module.encode & decode Another feature is to encode and decode dict. This will be useful if you plan to encode and decode many Dict's. print(d.encode(a)) -- {\"Lol\":{\"Hi\":1,\"Bruh\":2}} print(d.decode(a)) -- This would return its memory address module.getn Another feature is to get the amount of keys in a dict by running this: print(d.getn(a)) This would return 2 module.changed Lastly the a feature called d.changed(a) This behaves like a RBXScriptSignal . All you need to do is call on it with a dict and connect it, like this: d.changed(a):Connect(function(key, value) print(key) print(value) end) a.Lol.Hi = 3 -- Changing the value to spur the .Changed The arguments it returns is the key that changes and its value. In this case it prints: Hi 3 As it detects the change. This can be also used for deep tables that have tables nested inside of it. This allows you quickly set up .changed for your dict's and see when it changes. module.unpack This will return a tuple with a dict. This may have many caveats to it but works simply. local b,l,u = d.unpack({Hi = 1, Bye = 2, Lol = 2}) print(b,l,u) This will be in pairs with its Key and Value so this returns [Hi, 1], [Bye, 2], [Lol, 2] But they are still in table format in their isolated pairs. Caveats This may only work with Dict's an not tables in the future i may add support for tables for the .changed event. Since listening for changes was done for the intent of dict use it may not work with a regular array.","title":"About"},{"location":"about/#functions","text":"As you are aware this module comes with lots of functions that can be used from any script as you can require it. This is the basic table we will be using: local d = require(game.ReplicatedStorage.DictModule) -- This can be you requiring the module local a = { -- This is a test table that we will use ['Lol'] = { ['Hi'] = 1, ['Bruh'] = 2, } }","title":"Functions"},{"location":"about/#modulefind","text":"In order to find a spefic Key in this table you should do: print(d.find(a.Lol, 'Hi')) -- 1 d.find can be used on a regular table to do this print(d.find(a), 'Lol') The first argument must be the dict you are looking in and the second argument being the string Key Name","title":"module.find"},{"location":"about/#moduleremove","text":"You can also Remove Key's in a dict. The way to do this is to use d.remove print(d.remove(a.Lol, 'Hi')) The first arg must be the dict and the second arg must be the string name of what you are removing. Hence any refrences to a.Lol.Hi will be nil as it's gone from the table.","title":"module.remove"},{"location":"about/#moduleencode-decode","text":"Another feature is to encode and decode dict. This will be useful if you plan to encode and decode many Dict's. print(d.encode(a)) -- {\"Lol\":{\"Hi\":1,\"Bruh\":2}} print(d.decode(a)) -- This would return its memory address","title":"module.encode &amp; decode"},{"location":"about/#modulegetn","text":"Another feature is to get the amount of keys in a dict by running this: print(d.getn(a)) This would return 2","title":"module.getn"},{"location":"about/#modulechanged","text":"Lastly the a feature called d.changed(a) This behaves like a RBXScriptSignal . All you need to do is call on it with a dict and connect it, like this: d.changed(a):Connect(function(key, value) print(key) print(value) end) a.Lol.Hi = 3 -- Changing the value to spur the .Changed The arguments it returns is the key that changes and its value. In this case it prints: Hi 3 As it detects the change. This can be also used for deep tables that have tables nested inside of it. This allows you quickly set up .changed for your dict's and see when it changes.","title":"module.changed"},{"location":"about/#moduleunpack","text":"This will return a tuple with a dict. This may have many caveats to it but works simply. local b,l,u = d.unpack({Hi = 1, Bye = 2, Lol = 2}) print(b,l,u) This will be in pairs with its Key and Value so this returns [Hi, 1], [Bye, 2], [Lol, 2] But they are still in table format in their isolated pairs.","title":"module.unpack"},{"location":"about/#caveats","text":"This may only work with Dict's an not tables in the future i may add support for tables for the .changed event. Since listening for changes was done for the intent of dict use it may not work with a regular array.","title":"Caveats"}]}